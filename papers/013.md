# 013

**英文名称：** Transformer-XL: Attentive Language Models Beyond a Fixed-Length Context

**中文名称：** 

**论文地址：** https://arxiv.org/pdf/1901.02860.pdf

**期刊/时间：** ACL 2019

## 前置知识

## 摘要

- **问题是什么？**
- **我们要做什么？**
- **大概怎么做的**
- **实验效果**

Transformer具有学习长期依赖的潜力，但是在语言建模设置中被固定长度上下文限制。**本文提出了一种新颖的神经网络Transformer-XL，该模型不需要扰乱临时的条理性，能学习远超固定长度的依赖。该模型主要有段级递归机制和一种位置编码组成。本文的方法不仅能捕捉长期以来，而且能解决上下文碎片问题。**

因此，TransformerXL学习的依赖比rnn长80%，比vanilla transformer长450%，在短序列和长序列上都有更好的性能，在评估过程中比vanilla transformer快1800多倍。值得注意的是，我们将bpc/perplexity的最新结果在enwiki8上提高到0.99，在text8上提高到1.08，在WikiText-103上提高到18.3，在One Billion Word上提高到21.8，在Penn Treebank上提高到54.5(没有微调)。在只使用WikiText-103进行训练时，Transformer-XL能够使用数千个token生成相当连贯、新颖的文本文章。本文的代码、预训练模型和超参数在Tensorflow和PyTorch中都可用。

## 介绍

按照起承转合的思想阅读。
- **起。做的哪方面工作？**
- **承。相关工作**
- **转。相关工作的不足和转机**
- **合。本文工作**

语言建模是需要长期依赖建模的重要问题之一，有成功的应用，如无监督的预训练。然而，在序列数据中使用建模长期以来的能力来武装神经网络是一种挑战。RNN特别是LSTM，已经成为了一种语言建模和在多个benchmarks中获取较好结果的标准解决方案。尽管具有广泛的适应性，但由于梯度消失和爆炸(Hochreiter等，2001)，rnn很难优化，在LSTMs中引入门控和梯度裁剪技术(Graves, 2013)可能不足以完全解决这一问题。根据经验，先前的工作发现LSTM语言模型平均使用200个上下文单词(Khandelwal等，2018)，表明有进一步改进的空间。

另一方面，在注意机制中关注的的远距离词对之间的直接联系可能会缓解优化问题，并使学习长期依赖成为可能。最近，al - rfou等人(2018)设计了一组辅助Loss来训练深度Transformer网络，用于字符级语言建模，其性能大大优于LSTMs。尽管取得了成功，但al - rfou等人(2018)的LM训练是在几百个字符的固定长度的分离段上进行的，没有任何信息流跨段。**由于固定的上下文长度，模型不能捕获预定义的上下文长度以外的任何较长依赖项。此外，固定长度的片段是通过选择一个连续的符号块来创建的，而不考虑句子或任何其他语义边界。因此，该模型缺乏良好预测前几个符号所需的必要上下文信息，导致优化效率低，性能较差。本文将上述问题称为上下文碎片。**

为了解决上述固定长度上下文的局限性，本文提出了一种名为Transformer-XL(表示超长)的新体系结构。**本文将递归的概念引入到深层自注意力网络中。特别是，我们不是从头计算每个新段的隐藏状态，而是重用在以前的段中获得的隐藏状态。重用的隐藏状态作为当前段的内存，它在段之间建立了一个循环连接。因此，建模非常长期的依赖性成为可能，因为信息可以通过重复的连接传播。**同时，传递来自前一段的信息也可以解决上下文碎片化的问题。更重要的是，我们展示了使用相对位置编码而不是绝对位置编码的必要性，以便在不引起时间混乱的情况下实现状态重用。因此，作为一项额外的技术贡献，我们引入了一个简单但更有效的相对位置编码公式，它可以推广到比在训练中观察到的更长时间的注意长度。Transformer-XL在五个数据集上获得了较好的结果，这些数据集从单词级到字符级的语言建模不等。Transformer-XL还能够生成具有数千个token的相对一致的长文本文章，仅对100亿个token进行训练。

我们的主要技术贡献包括将递归概念引入到自注意力模型中和推导出一种新的位置编码方案。这两种技术构成了一套完整的解决方案，因为它们中的任何一种单独都不能解决固定长度上下文的问题。Transformer-XL是第一个在字符级和单词级语言建模方面都比rnn取得更好结果的自我注意模型。

## 相关工作

**主要介绍背景知识。**

## 方法

- **简要地重复问题**
- **解决思路**
- **必要的形式化定义**
- **具体模型**
  语言建模的任务是估计联合概率P(x),通过因式分解，问题简化为估计每个条件因子。

$$
P(\mathbf{x})=\prod_t P\left(x_t \mid \mathbf{x}_{<t}\right)
$$

本文坚持使用标准的神经网络方法来建模条件概率。将$x_{<t}$的上下文编码到一个固定长度的隐藏状态，其次通过词嵌入相乘获得logits，然后将其输入到Softmax函数中，迭代产生下一个token的分类概率分布。


### Vanilla Transformer

为了将Transformer或自我关注应用到语言建模中，**中心问题是如何训练Transformer有效地将任意长上下文编码为固定大小的表示。**

使用固定长度的上下文具有两个关键的限制。
- 与RNN相比，虽然自注意力机制被梯度消失问题影响较小，模型不能完全利用这种优化优势。
- 简单低将序列分为固定长度的段将会导致上下文碎片问题。

### 带状态重用的段级递归

在训练过程中，为前一个段计算的隐藏状态序列被固定并缓存，以便在模型处理下一个新段时作为扩展上下文重用，

![20221118150424](https://cdn.jsdelivr.net/gh/ironartisan/picRepo/20221118150424.png)

与截断BPTT方法不同的是，我们的方法缓存的是一个隐藏状态序列，而不是最后一个隐藏状态，并且需要与相对位置编码技术一起应用。除了实现超长上下文和解决碎片问题外，递归方案的另一个好处是计算速度显著加快。在评估期间，来自前一段的表示可以被重用，而不是像在vanilla模型中那样从头计算。在我们在enwiki8上的实验中，Transformer-XL在评估过程中比vanilla模型快了1800多倍。

最后，递归式方案不需要局限于前一段。理论上，可以在GPU内存允许的情况下尽可能多地缓存之前的段，并在处理当前段时重用所有这些段作为额外的上下文。

### 相对位置编码

当我们重用状态时，如何保持位置信息的一致性是一个难题。如果使用标准的Transformer的位置编码，模型无法分辨出位置的差异。为了防止这种错误情况发生，基本的思想是仅仅编码隐藏状态中的相对位置信息。从概念上讲，位置编码关于信息如何收集，提供模型一个暂时的线索或者偏见。为了达到同样的目的，我们可以将相同的信息注入到每一层的注意评分中，而不是将偏见静态地嵌入到初始嵌入中。

标准的Transformer中注意力分数：

$$
\begin{aligned}
\mathbf{A}_{i, j}^{\mathrm{abs}} &=\underbrace{\mathbf{E}_{x_i}^{\top} \mathbf{W}_q^{\top} \mathbf{W}_k \mathbf{E}_{x_j}}_{(a)}+\underbrace{\mathbf{E}_{x_i}^{\top} \mathbf{W}_q^{\top} \mathbf{W}_k \mathbf{U}_j}_{(b)} \\
&+\underbrace{\mathbf{U}_i^{\top} \mathbf{W}_q^{\top} \mathbf{W}_k \mathbf{E}_{x_j}}_{(c)}+\underbrace{\mathbf{U}_i^{\top} \mathbf{W}_q^{\top} \mathbf{W}_k \mathbf{U}_j}_{(d)}
\end{aligned}
$$

本文改进后的注意力分数表示为:

$$
\begin{aligned}
\mathbf{A}_{i, j}^{\mathrm{rel}} &=\underbrace{\mathbf{E}_{x_i}^{\top} \mathbf{W}_q^{\top} \mathbf{W}_{k, E} \mathbf{E}_{x_j}}_{(a)}+\underbrace{\mathbf{E}_{x_i}^{\top} \mathbf{W}_q^{\top} \mathbf{W}_{k, R} \mathbf{R}_{i-j}}_{(b)} \\
&+\underbrace{u^{\top} \mathbf{W}_{k, E} \mathbf{E}_{x_j}}_{(c)}+\underbrace{v^{\top} \mathbf{W}_{k, R} \mathbf{R}_{i-j}}_{(d)} .
\end{aligned}
$$

对比来看，主要有三点变化:
1. 在(b)和(d)这两项中，将所有绝对位置向量 $U_j$ 都转为相对位置向量 $R_{i-j}$ ，与Transformer一样，这是一个固定的编码向量，不需要学习。
2. 在 (c)这一项中，将查询的 $U_i^T W_q^T$ 向量转为一个需要学习的参数向量 $u$ ，因为在考虑相对位置的时候，不需要查询的绝对位置 $i$ ，因此对于任意的 $i$ ，都可以采用同样的向量。同理，在 $(\mathrm{d})$ 这一项中，也将查询的 $U_i^T W_q^T$ 向量转为另一个需要学习的参数向量 $v$。
3. 将键的权重变换矩阵 $W_k$ 转为 $W_{k, E}$ 和 $W_{k, R}$ ，分别作为content-based key vectors和location-based key vectors。

从另一个角度来解读这个公式的话，可以将attention的计算分为如下四个部分:

1. (a)为基于内容的“寻址”，即没有添加原始位置编码的原始分数。
2. (b)为基于内容的位置偏置，即相对于当前内容的位置偏差。
3. (c)为全局的内容偏置，用于衡量key的重要性。
4. (d)为全局的位置偏置，根据query和key之间的距离调整重要性。

## 实验

- **数据集和实验设置**

- **主实验，提供详尽的实验分析**

  ​


## 讨论与总结

Transformer-XL获得了较强的困惑结果，模型的依赖性比rnn和Transformer要长，在评估过程中实现了大幅度的加速，并能够生成连贯的文本文章。设想Transformer-XL在文本生成、无监督特征学习、图像和语音建模等领域的有趣应用。

1. 模型主要解决的问题是什么？
   - 上下文碎片问题。Transformer把要处理的文本分割成等长的片段，通常不考虑句子（语义）边界，导致上下文碎片化(context fragmentation)。通俗来讲，一个完整的句子在分割后，一半在前面的片段，一半在后面的片段。
   - 固定长度上下文的局限性。Transformer无法建模超过固定长度的依赖关系，对长文本编码效果差。

2. 模型的创新点和不足是什么？
   创新点：
- 提出片段级递归机制(segment-level recurrence mechanism)，引入一个记忆(memory)模块（类似于cache或cell），循环用来建模片段之间的联系。使得长距离依赖的建模成为可能；使得片段之间产生交互，解决上下文碎片化问题。
- 提出相对位置编码机制(relative position embedding scheme)，代替绝对位置编码。在memory的循环计算过程中，避免时序混淆，位置编码可重用。

  不足：
   -  在预训练的时候只利用了单向信息。
   -  对计算资源的要求比较高。

